# 基础DP

## 实现方法

### 记忆化搜索

仍以普通递归的方式，设 vis[] 表示某点是否访问过（已经计算出 dp[i]），若访问过，则直接返回 dp[i] 即可。
注意在求最大 d[i] 时，需要在主函数内遍历一遍 dp(i)。

### 递推

以多重循环的方式，思路相反。
有“填表法”和“刷表法”。

## 总结

* 一般都要初始化 d[] 和 vis[]
* 找不到如何设置状态转移变量时，想一想什么情况下的值一定确定（也就是找到可最优的子结构）
* 记忆化搜索时 min() 或 max() 内要用递归函数，不要误写成 dp[i][j]
* 初始化：先整体初始化为某特殊值，如 0、INF、-INF 等，再将已知的特定状态赋值。（通常一维为 0 ，另一维遍历初始化）
* 错误：初始化错误、内外层循环颠倒、滚动数组没滚好

## 背包问题

### 0-1 背包

即给定每个物品的重量和价值，求：在背包容量 C 内最大价值和。

示意代码（以下省略初始化过程）：
```C++
// 时间：O(n*n)
// 空间：O(n*n)
int dp[i][j]; // 前 i 个物品，重量不超过 j 时，的最大价值

// dp[i][j] = max(dp[i-1][j-wei[i]]+val[i], dp[i-1][j]);
for(int i = 0; i < n; i++){
    for(int j = 0; j <= C; j++){
        if(j - wei[i] >= 0){
            dp[i][j] = max(dp[i-1][j-wei[i]]+val[i], dp[i-1][j]);
        }
        else{
            dp[i][j] = dp[i-1][j];
        }
    }
}

cout << dp[n-1][C] << endl;
```
```C++
// 空间：O(n)
// 因为 dp[i][] 仅依赖 dp[i-1][]，所以可以滚动数组
int dp[j];

// dp[j] = max(dp[j-wei[i]]+val[i], dp[j]);
for(int i = 0; i < n; i++){
    // 因为 dp[i][j] 依赖于 dp[i-1][j] 和 dp[i-1][j-wei[i]]，
    // 所以为了避免新的 dp 影响第 i 行后续的更新，
    // 需要倒序遍历：
    for(int j = C; j >= wei[i]; j--){
        // 因为 j<wei[i] 时无法放入 i，即 dp[i][]==dp[i-1][]，
        // 所以无需再计算
        dp[j] = max(dp[j-wei[i]]+val[i], dp[j]);
    }
}
```

#### 装满

即，将初始化过程变为 dp[0][0] = 0, 其余 dp[0][i] = -INF，最终输出 dp[n-1][C] 即可

### 完全背包

每种物品数量不限；即，可以认为在选了第 i 种物品之后，还可以再选该种，但若从选 1 个遍历到 n 个的话，会使复杂度乘 n，因此，可以吧选 n 个看做为选了 n-1 个的基础上又选了一个，而选 n 个还是 n-1 个，是通过第二层循环“价格”控制的，即，使在更新状态 dp[j]时，dp[j - list[i].w] 时可能因为放入物品 i 而发生改变。

```C++
int dp[j];

for(int i = 0; i < n; i++){
    for(int j = wei[i]; j <= C; j++){
        dp[j] = max(dp[j], dp[j-wei[i]] + val[i]);
    }
}
```

### 多重背包

即，限制了每种物品的数量，介于 0-1 与 完全 之间。如完全背包所说，遍历第 i 种的 0~n 个，显然复杂度增长很多，因此可利用将 n 分解为多组：1,2,4,...n-2^x+1，如 9 = 1+2+4+2，1 2 4 保证了可以组合除 1~7，最后的 2 保证了可以组合出 1~9。以此，用“组数”替代“个数”，将数量从 n 大大减小到约为 logn。   

预处理，对第 i 种物品的数量 n 分解：
```C++
int base = 1;
// cnt 为 thing 的计数器
while (n - base > 0) {
    n -= base;
    thing[++cnt].wei = base * wei;
    thing[cnt].val = base * val; //拆分后的大米重量和价格均为组成该物品的大米的重量价格和 
    base *= 2;
}
thing[++cnt].wei = wei * n;
thing[cnt].val = val * n;
```

之后对其进行 0-1 背包（逆序遍历容量）

## 滚动数组

```C++
int *src; //源指针   
int *des; //目的指针 
// 由于初始状态保存在 dp 数组的第 0 行中，初始时：
src = dp[1];
des = dp[0];
// 按照状态转移方程进行状态转移   
for (int i = 1;i <= n;i ++) { 
    swap(src,des); //交换源和目的指针 
    for (int j = 1;j <= m;j ++) { 
        des[j] = max(src[j + 1],src[j - 1]);  
    } 
}   
int ans = des[m];
```

当然，也可以通过 0/1 来轮流取第一维或第二维。