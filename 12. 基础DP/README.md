# 基础DP

## 状态转移方程

暂略

## 实现方法

### 记忆化搜索

仍以普通递归的方式，设 vis[] 表示某点是否访问过（已经计算出 dp[i]），若访问过，则直接返回 dp[i] 即可。
注意在求最大 d[i] 时，需要在主函数内遍历一遍 dp(i)。

### 递推

以多重循环的方式，思路相反。
有“填表法”和“刷表法”。

## 总结

* 一般都要初始化 d[] 和 vis[]
* 找不到如何设置状态转移变量时，想一想什么情况下的值一定确定（也就是找到可最优的子结构）
* 记忆化搜索时 min() 或 max() 内要用递归函数，不要误写成 dp[i][j]