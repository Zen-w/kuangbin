# 排序

* 内部排序：能够在内存中进行一次性的排序

* 外部排序：无法一次性放入内存

## 简单排序

### 冒泡排序

稳定；复杂度：
* 最好情况：O(n)，即初始正序
* 最坏情况：O(n^2^)，即初始逆序

每次遍历，比较相邻两元素，即每趟排序选出一个最大的元素放到末尾，重复 n 或 n-1 次；

可设置标记，若一趟排序中没有进行过元素交换，则说明已经排序完成，结束即可；


性质：
* 可用于链表
* 稳定

### 插入

稳定；复杂度：
* 最好情况：O(n)，即初始正序
* 最坏情况：O(n^2^)，即初始逆序

从后向前遍历元素，若待插入元素 x 小于遍历到的元素 i，则 i 后移（相当于交换）；

逆序对：即序列中为“逆序”的数据对，要交换次数即为逆序对数 I，所以复杂度实则为 O(n+I)

定理：
* 任意序列平均具有 n(n-1)/4 个逆序对
* 任何仅以交换相邻两元素的排序算法的复杂度为 Ω(n^2^)，即至少为 n^2^

所以，要提高效率，需要尽可能每次交换消除不只 1 个逆序对

#### 希尔排序

不稳定；复杂度：
* 平均：O(n^d^) 取决于增量序列的选择
* 最坏：O(n^2^)

取“间隔”序列，其中一种：从 floor(N/2), 再除以 2，直到 1；

每次取间隔元素进行插入排序；

## 选择排序&堆排序

### 选择排序

不稳定；复杂度：
* 平均：O(n^2^)

每次遍历挑选一个最小的，与序列首交换；

### 堆排序

不稳定；复杂度：
* 时间复杂度：O(nlogn)，但需要乘一个“常数”
* 空间复杂度：O(n)

基本思想：基于小顶堆，建堆（n），每次取最小（logn）共 n 次，复制回原数组（n）。

优化：直接对原数组（本身就是完全二叉树），进行建大顶堆，之后每一次将顶上最大元素与最后一个元素交换，再调整（logn），所以省去了 n 的空间，时间仍约为 nlogn；

但可能仍不如使用 sedgewick 增量序列的希尔排序；

## 归并排序

稳定；复杂度：
* 时间：恒为 O(nlog)
* 空间：O(n)，且需要经常复制数据

本质：**分治**

核心：有序子序列的合并

性质：
* 可用于外排序

### 递归实现

先递归生成左半有序序列，再生成右半有序序列，再合并为有序序列

### 非递归实现

略